
<!DOCTYPE html>



<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Binary Tree Applications &mdash; Python Courseware</title>
    
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/video.css" type="text/css" />
    <link rel="stylesheet" href="../_static/codelens/v3/css/pytutor.css" type="text/css" />
    <link rel="stylesheet" href="../_static/codelens/v3/css/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/codelens/v3/css/ui-lightness/jquery-ui-1.8.24.custom.css" type="text/css" />
    <link rel="stylesheet" href="../_static/codemirror.css" type="text/css" />
    <link rel="stylesheet" href="../_static/theme/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/activecode.css" type="text/css" />
    <link rel="stylesheet" href="../_static/js-parsons/parsons.css" type="text/css" />
    <link rel="stylesheet" href="../_static/js-parsons/lib/prettify.css" type="text/css" />
    <link rel="stylesheet" href="../_static/user-highlights.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/codelens/v3/js/jquery.simplemodal.js"></script>
    <script type="text/javascript" src="../_static/codelens/v3/js/d3.v2.min.js"></script>
    <script type="text/javascript" src="../_static/codelens/v3/js/jquery.ba-bbq.min.js"></script>
    <script type="text/javascript" src="../_static/codelens/v3/js/jquery.jsPlumb-1.3.10-all-min.js"></script>
    <script type="text/javascript" src="../_static/codelens/v3/js/jquery-ui-1.8.24.custom.min.js"></script>
    <script type="text/javascript" src="../_static/codelens/v3/js/pytutor.js"></script>
    <script type="text/javascript" src="../_static/jquery.highlight.js"></script>
    <script type="text/javascript" src="../_static/bookfuncs.js"></script>
    <script type="text/javascript" src="../_static/codemirror.js"></script>
    <script type="text/javascript" src="../_static/python.js"></script>
    <script type="text/javascript" src="../_static/activecode.js"></script>
    <script type="text/javascript" src="../_static/skulpt/dist/skulpt.js"></script>
    <script type="text/javascript" src="../_static/skulpt/dist/builtin.js"></script>
    <script type="text/javascript" src="../_static/assess.js"></script>
    <script type="text/javascript" src="../_static/animationbase.js"></script>
    <script type="text/javascript" src="../_static/js-parsons/lib/jquery.min.js"></script>
    <script type="text/javascript" src="../_static/js-parsons/lib/jquery-ui.min.js"></script>
    <script type="text/javascript" src="../_static/js-parsons/lib/prettify.js"></script>
    <script type="text/javascript" src="../_static/js-parsons/lib/underscore-min.js"></script>
    <script type="text/javascript" src="../_static/js-parsons/lib/lis.js"></script>
    <script type="text/javascript" src="../_static/js-parsons/parsons.js"></script>
    <script type="text/javascript" src="../_static/parsons-noconflict.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../_static/rangy-core.js"></script>
    <script type="text/javascript" src="../_static/rangy-textrange.js"></script>
    <script type="text/javascript" src="../_static/rangy-cssclassapplier.js"></script>
    <script type="text/javascript" src="../_static/user-highlights.js"></script>
    <link rel="top" title="Python Courseware" href="../index.html" />
    <link rel="next" title="Priority Queues with Binary Heaps" href="heap.html" />
    <link rel="prev" title="Implementation" href="implementation.html" />
<script type="text/javascript">
eBookConfig = {}
eBookConfig.host = 'http://127.0.0.1:8000' ? 'http://127.0.0.1:8000' : 'http://127.0.0.1:8000',
eBookConfig.app = eBookConfig.host+'/runestone',
eBookConfig.ajaxURL = eBookConfig.app+'/ajax/',
eBookConfig.course = 'pd',
eBookConfig.logLevel = 10,
eBookConfig.loginRequired = true
eBookConfig.isLoggedIn = false;
</script>
<script type="text/javascript" charset="utf-8" src="http://127.0.0.1:8000/runestone/static/js/jquery.idle-timer.js">
</script>
<script type="text/javascript" src="http://127.0.0.1:8000/runestone/static/js/processing-1.4.1.min.js"></script>
<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>


  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="heap.html" title="Priority Queues with Binary Heaps"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="implementation.html" title="Implementation"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Python Courseware</a> &raquo;</li>
<li class="right"><span class="loginout"><a href="/runestone/default/user/logout">logout</a></span>| </li>

      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <p class="logo"><a href="../index.html">
    <img class="logo" src="../_static/logo.jpg" alt="Logo" title="Click for Main Table of Contents"/>
  </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Binary Tree Applications</a><ul>
<li><a class="reference internal" href="#parse-tree">Parse Tree</a></li>
<li><a class="reference internal" href="#tree-traversals">Tree Traversals</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="implementation.html"
                        title="previous chapter">Implementation</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="heap.html"
                        title="next chapter">Priority Queues with Binary Heaps</a></p><div id="runestonebox">
  <h3>Runestone Links</h3>
  <ul>
    <li> <span id="numuserspan"></span> Readers Online Now </li>
    <li>
      <a href="/runestone/static/pd/navhelp.html">Navigation Help</a>
    </li>
    <li>
      <a href="https://github.com/bnmnetp/runestone/issues/new">Report a Problem</a>
    </li>
    <li>
      <a href="http://runestoneinteractive.org">About Runestone</a>
    </li>
    <li>
      <a href="/runestone/admin/index">Instructors Page</a>
    </li>
  </ul>
<div class="fb-like" data-href="http://www.facebook.com/RunestoneInteractive" data-send="false" data-layout="button_count" data-width="220" data-show-faces="false"></div>
<p><a href="https://twitter.com/iRunestone" class="twitter-follow-button" data-show-count="false">Follow @iRunestone</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script></p>
</div>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="binary-tree-applications">
<h1>Binary Tree Applications<a class="headerlink" href="#binary-tree-applications" title="Permalink to this headline">¶</a></h1>
<div class="section" id="parse-tree">
<h2>Parse Tree<a class="headerlink" href="#parse-tree" title="Permalink to this headline">¶</a></h2>
<p>With the implementation of our tree data structure
complete, we now look at an example of how a tree can be used to solve
some real problems. In this section we will look at parse trees. Parse
trees can be used to represent real-world constructions like sentences
(see <a class="reference internal" href="#fig-nlparse"><em>Figure x</em></a>), or mathematical expressions.</p>
<div class="figure align-center" id="fig-nlparse">
<img alt="image" src="../_images/nlParse.png" />
<p class="caption">A Parse Tree for a Simple Sentence</p>
</div>
<p><a class="reference internal" href="#fig-nlparse"><em>Figure x</em></a> shows the hierarchical structure of a simple
sentence. Representing a sentence as a tree structure allows us to work
with the individual parts of the sentence by using subtrees.</p>
<div class="figure align-center" id="fig-meparse">
<img alt="image" src="../_images/meParse.png" />
<p class="caption">Parse Tree for <span class="math">\(((7+3)*(5-2))\)</span></p>
</div>
<p>We can also represent a mathematical expression such as
<span class="math">\(((7 + 3) * (5 - 2))\)</span> as a parse tree, as shown in
<a class="reference internal" href="#fig-meparse"><em>Figure x</em></a>. We have already looked at fully parenthesized
expressions, so what do we know about this expression? We know that
multiplication has a higher precedence than either addition or
subtraction. Because of the parentheses, we know that before we can do
the multiplication we must evaluate the parenthesized addition and
subtraction expressions. The hierarchy of the tree helps us understand
the order of evaluation for the whole expression. Before we can evaluate
the top-level multiplication, we must evaluate the addition and the
subtraction in the subtrees. The addition, which is the left subtree,
evaluates to 10. The subtraction, which is the right subtree, evaluates
to 3. Using the hierarchical structure of trees, we can simply replace
an entire subtree with one node once we have evaluated the expressions
in the children. Applying this replacement procedure gives us the
simplified tree shown in <a class="reference internal" href="#fig-mesimple"><em>Figure x</em></a>.</p>
<div class="figure align-center" id="fig-mesimple">
<img alt="image" src="../_images/meSimple.png" />
<p class="caption">A Simplified Parse Tree for <span class="math">\(((7+3)*(5-2))\)</span></p>
</div>
<p>In the rest of this section we are going to examine parse trees in more
detail. In particular we will look at</p>
<ul class="simple">
<li>How to build a parse tree from a fully parenthesized mathematical
expression.</li>
<li>How to evaluate the expression stored in a parse tree.</li>
<li>How to recover the original mathematical expression from a parse
tree.</li>
</ul>
<p>The first step in building a parse tree is to break up the expression
string into a list of tokens. There are four different kinds of tokens
to consider: left parentheses, right parentheses, operators, and
operands. We know that whenever we read a left parenthesis we are
starting a new expression, and hence we should create a new tree to
correspond to that expression. Conversely, whenever we read a right
parenthesis, we have finished an expression. We also know that operands
are going to be leaf nodes and children of their operators. Finally, we
know that every operator is going to have both a left and a right child.</p>
<p>Using the information from above we can define four rules as follows:</p>
<ol class="arabic simple">
<li>If the current token is a <tt class="docutils literal"><span class="pre">'('</span></tt>, add a new node as the left child
of the current node, and descend to the left child.</li>
<li>If the current token is in the list <tt class="docutils literal"><span class="pre">['+','-','/','*']</span></tt>, set the
root value of the current node to the operator represented by the
current token. Add a new node as the right child of the current node
and descend to the right child.</li>
<li>If the current token is a number, set the root value of the current
node to the number and return to the parent.</li>
<li>If the current token is a <tt class="docutils literal"><span class="pre">')'</span></tt>, go to the parent of the current
node.</li>
</ol>
<p>Before writing the Python code, let’s look at an example of the rules
outlined above in action. We will use the expression
<span class="math">\((3 + (4 * 5))\)</span>. We will parse this expression into the
following list of character tokens <tt class="docutils literal"><span class="pre">['(',</span> <span class="pre">'3',</span> <span class="pre">'+',</span></tt>
<tt class="docutils literal"><span class="pre">'(',</span> <span class="pre">'4',</span> <span class="pre">'*',</span> <span class="pre">'5'</span> <span class="pre">,')',')']</span></tt>. Initially we will start out with a
parse tree that consists of an empty root node. <a class="reference internal" href="#fig-bldexpstep"><em>Figure x</em></a>
illustrates the structure and contents of the parse tree, as each new
token is processed.</p>
<div class="figure align-center" id="fig-bldexpstep">
<img alt="image" src="../_images/buildExp1.png" />
</div>
<div class="figure align-center">
<img alt="image" src="../_images/buildExp2.png" />
</div>
<div class="figure align-center">
<img alt="image" src="../_images/buildExp3.png" />
</div>
<div class="figure align-center">
<img alt="image" src="../_images/buildExp4.png" />
</div>
<div class="figure align-center">
<img alt="image" src="../_images/buildExp5.png" />
</div>
<div class="figure align-center">
<img alt="image" src="../_images/buildExp6.png" />
</div>
<div class="figure align-center">
<img alt="image" src="../_images/buildExp7.png" />
</div>
<div class="figure align-center">
<img alt="image" src="../_images/buildExp8.png" />
<p class="caption">Tracing Parse Tree Construction</p>
</div>
<p>Using <a class="reference internal" href="#fig-bldexpstep"><em>Figure x</em></a>, let’s walk through the example step by
step:</p>
<ol class="loweralpha simple">
<li>Create an empty tree.</li>
<li>Read ( as the first token. By rule 1, create a new node as the left
child of the root. Make the current node this new child.</li>
<li>Read 3 as the next token. By rule 3, set the root value of the
current node to 3 and go back up the tree to the parent.</li>
<li>Read + as the next token. By rule 2, set the root value of the
current node to + and add a new node as the right child. The new
right child becomes the current node.</li>
<li>Read a ( as the next token. By rule 1, create a new node as the left
child of the current node. The new left child becomes the current
node.</li>
<li>Read a 4 as the next token. By rule 3, set the value of the current
node to 4. Make the parent of 4 the current node.</li>
<li>Read * as the next token. By rule 2, set the root value of the
current node to * and create a new right child. The new right child
becomes the current node.</li>
<li>Read 5 as the next token. By rule 3, set the root value of the
current node to 5. Make the parent of 5 the current node.</li>
<li>Read ) as the next token. By rule 4 we make the parent of * the
current node.</li>
<li>Read ) as the next token. By rule 4 we make the parent of + the
current node. At this point there is no parent for + so we are done.</li>
</ol>
<p>From the example above, it is clear that we need to keep track of the
current node as well as the parent of the current node. The tree
interface provides us with a way to get children of a node, through the
<tt class="docutils literal"><span class="pre">getLeftChild</span></tt> and <tt class="docutils literal"><span class="pre">getRightChild</span></tt> methods, but how can we keep
track of the parent? A simple solution to keeping track of parents as we
traverse the tree is to use a stack. Whenever we want to descend to a
child of the current node, we first push the current node on the stack.
When we want to return to the parent of the current node, we pop the
parent off the stack.</p>
<p>Using the rules described above, along with the <tt class="docutils literal"><span class="pre">Stack</span></tt> and
<tt class="docutils literal"><span class="pre">BinaryTree</span></tt> operations, we are now ready to write a Python function
to create a parse tree. The code for our parse tree builder is presented
in Listing&nbsp;{lst:buildexp}.</p>

<div id="parsebuild" >

<br/>
<div id="parsebuild_code_div" style="display: block">
<textarea cols="50" rows="12" id="parsebuild_code" class="active_code">
from pythonds.basic.stack import Stack
from pythonds.trees.binaryTree import BinaryTree

def buildParseTree(fpexp):
    fplist = fpexp.split()
    pStack = Stack()
    eTree = BinaryTree('')
    pStack.push(eTree)
    currentTree = eTree
    for i in fplist:
        if i == '(':
            currentTree.insertLeft('')
            pStack.push(currentTree)
            currentTree = currentTree.getLeftChild()
        elif i not in ['+', '-', '*', '/', ')']:
            currentTree.setRootVal(int(i))
            parent = pStack.pop()
            currentTree = parent
        elif i in ['+', '-', '*', '/']:
            currentTree.setRootVal(i)
            currentTree.insertRight('')
            pStack.push(currentTree)
            currentTree = currentTree.getRightChild()
        elif i == ')':
            currentTree = pStack.pop()
        else:
            raise ValueError
    return eTree

pt = buildParseTree("( ( 10 + 5 ) * 3 )")
pt.postorder()
</textarea>
</div>
<p class="ac_caption"><span class="ac_caption_text">Building a Parse Tree (parsebuild)</span> </p>

<button id="parsebuild_runb" onclick="runit('parsebuild',this, undefined);">Run</button>

<div id="cont"></div>

<button class="ac_opt" onclick="saveEditor('parsebuild');">Save</button>
<button class="ac_opt" onclick="requestCode('parsebuild');">Load</button>

<div style="text-align: center">
<canvas id="parsebuild_canvas" height="400" width="400" style="border-style: solid; display: none; text-align: center"></canvas>
</div>

<pre id="parsebuild_pre" class="active_out">

</pre>


</div>

<p>The four rules for building a parse tree are coded as the first four
clauses of the <tt class="docutils literal"><span class="pre">if</span></tt> statement on lines {lst:ptlp}, {lst:ptoper},
{lst:ptopnd}, and {lst:ptrp} of Listing&nbsp;{lst:buildexp}. In each case you
can see that the code implements the rule, as described above, with a
few calls to the <tt class="docutils literal"><span class="pre">BinaryTree</span></tt> or <tt class="docutils literal"><span class="pre">Stack</span></tt> methods. The only error
checking we do in this function is in the <tt class="docutils literal"><span class="pre">else</span></tt> clause, where we
raise a <tt class="docutils literal"><span class="pre">ValueError</span></tt> exception if we get a token from the list that we
do not recognize.</p>
<p>Now that we have built a parse tree, what can we do with it? As a first
example, we will write a function to evaluate the parse tree, returning
the numerical result. To write this function, we will make use of the
hierarchical nature of the tree. Look back at <a class="reference internal" href="#fig-meparse"><em>Figure x</em></a>.
Recall that we can replace the original tree with the simplified tree
shown in <a class="reference internal" href="#fig-mesimple"><em>Figure x</em></a>. This suggests that we can write an
algorithm that evaluates a parse tree by recursively evaluating each
subtree.</p>
<p>As we have done with past recursive algorithms, we will begin the design
for the recursive evaluation function by identifying the base case. A
natural base case for recursive algorithms that operate on trees is to
check for a leaf node. In a parse tree, the leaf nodes will always be
operands. Since numerical objects like integers and floating points
require no further interpretation, the <tt class="docutils literal"><span class="pre">evaluate</span></tt> function can simply
return the value stored in the leaf node. The recursive step that moves
the function toward the base case is to call <tt class="docutils literal"><span class="pre">evaluate</span></tt> on both the
left and the right children of the current node. The recursive call
effectively moves us down the tree, toward a leaf node.</p>
<p>To put the results of the two recursive calls together, we can simply
apply the operator stored in the parent node to the results returned
from evaluating both children. In the example from <a class="reference internal" href="#fig-mesimple"><em>Figure x</em></a>
we see that the two children of the root evaluate to themselves, namely
10 and 3. Applying the multiplication operator gives us a final result
of 30.</p>
<p>The code for a recursive <tt class="docutils literal"><span class="pre">evaluate</span></tt> function is shown in
Listing&nbsp;{lst:eteval}. First, we obtain references to the left and the
right children of the current node. If both the left and right children
evaluate to <tt class="docutils literal"><span class="pre">None</span></tt>, then we know that the current node is really a
leaf node. This check is on line {lst:etbc}. If the current node is not
a leaf node, look up the operator in the current node and apply it to
the results from recursively evaluating the left and right children.</p>
<p>To implement, we use a dictionary with the keys <tt class="docutils literal"><span class="pre">'+',</span> <span class="pre">'-',</span> <span class="pre">'*'</span></tt>, and
<tt class="docutils literal"><span class="pre">'/'</span></tt>. The values stored in the dictionary are functions from Python’s
operator module. The operator module provides us with the functional
versions of many commonly used operators. When we look up an operator in
the dictionary, the corresponding function object is retrieved. Since
the retrieved object is a function, we can call it in the usual way
<tt class="docutils literal"><span class="pre">function(param1,param2)</span></tt>. So the lookup <tt class="docutils literal"><span class="pre">opers['+'](2,2)</span></tt> is
equivalent to <tt class="docutils literal"><span class="pre">operator.add(2,2)</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="n">parseTree</span><span class="p">):</span>
    <span class="n">opers</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;+&#39;</span><span class="p">:</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="s">&#39;-&#39;</span><span class="p">:</span><span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">,</span>
         <span class="s">&#39;*&#39;</span><span class="p">:</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="s">&#39;/&#39;</span><span class="p">:</span><span class="n">operator</span><span class="o">.</span><span class="n">truediv</span><span class="p">}</span>
    <span class="n">leftC</span> <span class="o">=</span> <span class="n">parseTree</span><span class="o">.</span><span class="n">getLeftChild</span><span class="p">()</span>
    <span class="n">rightC</span> <span class="o">=</span> <span class="n">parseTree</span><span class="o">.</span><span class="n">getRightChild</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">leftC</span> <span class="ow">and</span> <span class="n">rightC</span><span class="p">:</span>  <span class="c">#// \label{lst:etbc}</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">opers</span><span class="p">[</span><span class="n">parseTree</span><span class="o">.</span><span class="n">getRootVal</span><span class="p">()]</span>
        <span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="n">evaluate</span><span class="p">(</span><span class="n">leftC</span><span class="p">),</span><span class="n">evaluate</span><span class="p">(</span><span class="n">rightC</span><span class="p">))</span> <span class="c">#//\label{lst:evalexprec}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">parseTree</span><span class="o">.</span><span class="n">getRootVal</span><span class="p">()</span>
</pre></div>
</div>
<p>Finally, we will trace the <tt class="docutils literal"><span class="pre">evaluate</span></tt> function on the parse tree we
created in <a class="reference internal" href="#fig-bldexpstep"><em>Figure x</em></a>. When we first call <tt class="docutils literal"><span class="pre">evaluate</span></tt>, we
pass the root of the entire tree as the parameter <tt class="docutils literal"><span class="pre">parseTree</span></tt>. Then we
obtain references to the left and right children to make sure they
exist. The recursive call takes place on line {lst:evalexprec}. We begin
by looking up the operator in the root of the tree, which is <tt class="docutils literal"><span class="pre">'+'</span></tt>.
The <tt class="docutils literal"><span class="pre">'+'</span></tt> operator maps to the <tt class="docutils literal"><span class="pre">operator.add</span></tt> function call, which
takes two parameters. As usual for a Python function call, the first
thing Python does is to evaluate the parameters that are passed to the
function. In this case both parameters are recursive function calls to
our <tt class="docutils literal"><span class="pre">evaluate</span></tt> function. Using left-to-right evaluation, the first
recursive call goes to the left. In the first recursive call the
<tt class="docutils literal"><span class="pre">evaluate</span></tt> function is given the left subtree. We find that the node
has no left or right children, so we are in a leaf node. When we are in
a leaf node we just return the value stored in the leaf node as the
result of the evaluation. In this case we return the integer 3.</p>
<p>At this point we have one parameter evaluated for our top-level call to
<tt class="docutils literal"><span class="pre">operator.add</span></tt>. But we are not done yet. Continuing the left-to-right
evaluation of the parameters, we now make a recursive call to evaluate
the right child of the root. We find that the node has both a left and a
right child so we look up the operator stored in this node, <tt class="docutils literal"><span class="pre">'*'</span></tt>, and
call this function using the left and right children as the parameters.
At this point you can see that both recursive calls will be to leaf
nodes, which will evaluate to the integers four and five respectively.
With the two parameters evaluated, we return the result of
<tt class="docutils literal"><span class="pre">operator.mul(4,5)</span></tt>. At this point we have evaluated the operands for
the top level <tt class="docutils literal"><span class="pre">'+'</span></tt> operator and all that is left to do is finish the
call to <tt class="docutils literal"><span class="pre">operator.add(3,20)</span></tt>. The result of the evaluation of the
entire expression tree for <span class="math">\((3 + (4 * 5))\)</span> is 23.</p>
</div>
<div class="section" id="tree-traversals">
<h2>Tree Traversals<a class="headerlink" href="#tree-traversals" title="Permalink to this headline">¶</a></h2>
<p>Now that we have examined the basic functionality of our
tree data structure, it is time to look at some additional usage
patterns for trees. These usage patterns can be divided into the three
ways that we access the nodes of the tree. There are three commonly used
patterns to visit all the nodes in a tree. The difference between these
patterns is the order in which each node is visited. We call this
visitation of the nodes a “traversal.” The three traversals we will look
at are called <strong>preorder</strong>, <strong>inorder</strong>, and <strong>postorder</strong>. Let’s start
out by defining these three traversals more carefully, then look at some
examples where these patterns are useful.</p>
<dl class="docutils">
<dt>preorder</dt>
<dd>In a preorder traversal, we visit the root node first, then
recursively do a preorder traversal of the left subtree, followed by
a recursive preorder traversal of the right subtree.</dd>
<dt>inorder</dt>
<dd>In an inorder traversal, we recursively do an inorder traversal on
the left subtree, visit the root node, and finally do a recursive
inorder traversal of the right subtree.</dd>
<dt>postorder</dt>
<dd>In a postorder traversal, we recursively do a postorder traversal of
the left subtree and the right subtree followed by a visit to the
root node.</dd>
</dl>
<p>Let’s look at some examples that illustrate each of these three kinds of
traversals. First let’s look at the preorder traversal. As an example of
a tree to traverse, we will represent this book as a tree. The book is
the root of the tree, and each chapter is a child of the root. Each
section within a chapter is a child of the chapter, and each subsection
is a child of its section, and so on. <a class="reference internal" href="#fig-booktree"><em>Figure x</em></a> shows a
limited version of a book with only two chapters. Note that the
traversal algorithm works for trees with any number of children, but we
will stick with binary trees for now.</p>
<div class="figure align-center" id="fig-booktree">
<img alt="image" src="../_images/booktree.png" />
<p class="caption">Representing a Book as a Tree</p>
</div>
<p>Suppose that you wanted to read this book from front to back. The
preorder traversal gives you exactly that ordering. Starting at the root
of the tree (the Book node) we will follow the preorder traversal
instructions. We recursively call <tt class="docutils literal"><span class="pre">preorder</span></tt> on the left child, in
this case Chapter1. We again recursively call <tt class="docutils literal"><span class="pre">preorder</span></tt> on the left
child to get to Section 1.1. Since Section 1.1 has no children, we do
not make any additional recursive calls. When we are finished with
Section 1.1, we move up the tree to Chapter 1. At this point we still
need to visit the right subtree of Chapter 1, which is Section 1.2. As
before we visit the left subtree, which brings us to Section 1.2.1, then
we visit the node for Section 1.2.2. With Section 1.2 finished, we
return to Chapter 1. Then we return to the Book node and follow the same
procedure for Chapter 2.</p>
<p>The code for writing tree traversals is surprisingly elegant, largely
because the traversals are written recursively. Listing&nbsp;{lst:preorder}
shows the Python code for a preorder traversal of a binary tree.</p>
<p>You may wonder, what is the best way to write an algorithm like preorder
traversal? Should it be a function that simply uses a tree as a data
structure, or should it be a method of the tree data structure itself?
Listing&nbsp;{lst:preordext} shows a version of the preorder traversal
written as an external function that takes a binary tree as a parameter.
The external function is particularly elegant because our base case is
simply to check if the tree exists. If the tree parameter is <tt class="docutils literal"><span class="pre">None</span></tt>,
then the function returns without taking any action.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">preorder</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">tree</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">getRootVal</span><span class="p">())</span>
        <span class="n">preorder</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">getLeftChild</span><span class="p">())</span>
        <span class="n">preorder</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">getRightChild</span><span class="p">())</span>
</pre></div>
</div>
<p>We can also implement <tt class="docutils literal"><span class="pre">preorder</span></tt> as a method of the <tt class="docutils literal"><span class="pre">BinaryTree</span></tt>
class. The code for implementing <tt class="docutils literal"><span class="pre">preorder</span></tt> as an internal method is
shown in Listing&nbsp;{lst:preorder}. Notice what happens when we move the
code from internal to external. In general, we just replace <tt class="docutils literal"><span class="pre">tree</span></tt>
with <tt class="docutils literal"><span class="pre">self</span></tt>. However, we also need to modify the base case. The
internal method must check for the existence of the left and the right
children <em>before</em> making the recursive call to <tt class="docutils literal"><span class="pre">preorder</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">preorder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">leftChild</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">preorder</span><span class="p">()</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rightChild</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">preorder</span><span class="p">()</span>
</pre></div>
</div>
<p>Which of these two ways to implement <tt class="docutils literal"><span class="pre">preorder</span></tt> is best? The answer is
that implementing <tt class="docutils literal"><span class="pre">preorder</span></tt> as an external function is probably
better in this case. The reason is that you very rarely want to just
traverse the tree. In most cases you are going to want to accomplish
something else while using one of the basic traversal patterns. In fact,
we will see in the next example that the <tt class="docutils literal"><span class="pre">postorder</span></tt> traversal pattern
follows very closely with the code we wrote earlier to evaluate a parse
tree. Therefore we will write the rest of the traversals as external
functions.</p>
<p>The algorithm for the <tt class="docutils literal"><span class="pre">postorder</span></tt> traversal, in
Listing&nbsp;{lst:postorder} is nearly identical to <tt class="docutils literal"><span class="pre">preorder</span></tt>, except that
we move the call to print to the end of the function.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">postorder</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">tree</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">postorder</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">getLeftChild</span><span class="p">())</span>
        <span class="n">postorder</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">getRightChild</span><span class="p">())</span>
        <span class="k">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">getRootVal</span><span class="p">())</span>
</pre></div>
</div>
<p>We have already seen a common use for the postorder traversal, namely
evaluating a parse tree. Look back at Listing&nbsp;{lst:eteval} again. What
we are doing is evaluating the left subtree, evaluating the right
subtree, and combining them in the root through the function call to an
operator. Assume that our binary tree is going to store only expression
tree data. Let’s rewrite the evaluation function, but model it even more
closely on the <tt class="docutils literal"><span class="pre">postorder</span></tt> code in Listing&nbsp;{lst:postorder}.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">postordereval</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
    <span class="n">opers</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;+&#39;</span><span class="p">:</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="s">&#39;-&#39;</span><span class="p">:</span><span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">,</span>
         <span class="s">&#39;*&#39;</span><span class="p">:</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="s">&#39;/&#39;</span><span class="p">:</span><span class="n">operator</span><span class="o">.</span><span class="n">truediv</span><span class="p">}</span>
    <span class="n">res1</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">res2</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="n">tree</span><span class="p">:</span>
        <span class="n">res1</span> <span class="o">=</span> <span class="n">postordereval</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">getLeftChild</span><span class="p">())</span>  <span class="c">#// \label{peleft}</span>
        <span class="n">res2</span> <span class="o">=</span> <span class="n">postordereval</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">getRightChild</span><span class="p">())</span> <span class="c">#// \label{peright}</span>
        <span class="k">if</span> <span class="n">res1</span> <span class="ow">and</span> <span class="n">res2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">opers</span><span class="p">[</span><span class="n">tree</span><span class="o">.</span><span class="n">getRootVal</span><span class="p">()](</span><span class="n">res1</span><span class="p">,</span><span class="n">res2</span><span class="p">)</span> <span class="c">#// \label{peeval}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tree</span><span class="o">.</span><span class="n">getRootVal</span><span class="p">()</span>
</pre></div>
</div>
<p>Notice that the form in Listing&nbsp;{lst:posteval} is the same as the form
in Listing&nbsp;{lst:postorder}, except that instead of printing the key at
the end of the function, we return it. This allows us to save the values
returned from the recursive calls in lines {peleft} and {peright}. We
then use these saved values along with the operator on line {peeval}.</p>
<p>The final traversal we will look at in this section is the inorder
traversal. In the inorder traversal we visit the left subtree, followed
by the root, and finally the right subtree. Listing&nbsp;{lst:inorder} shows
our code for the inorder traversal. Notice that in all three of the
traversal functions we are simply changing the position of the <tt class="docutils literal"><span class="pre">print</span></tt>
statement with respect to the two recursive function calls.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">inorder</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">tree</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
      <span class="n">inorder</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">getLeftChild</span><span class="p">())</span>
      <span class="k">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">getRootVal</span><span class="p">())</span>
      <span class="n">inorder</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">getRightChild</span><span class="p">())</span>
</pre></div>
</div>
<p>If we perform a simple inorder traversal of a parse tree we get our
original expression back, without any parentheses. Let’s modify the
basic inorder algorithm to allow us to recover the fully parenthesized
version of the expression. The only modifications we will make to the
basic template are as follows: print a left parenthesis <em>before</em> the
recursive call to the left subtree, and print a right parenthesis
<em>after</em> the recursive call to the right subtree. The modified code is
shown in Listing&nbsp;{lst:prtfpe}.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">printexp</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
  <span class="n">sVal</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
  <span class="k">if</span> <span class="n">tree</span><span class="p">:</span>
      <span class="n">sVal</span> <span class="o">=</span> <span class="s">&#39;(&#39;</span> <span class="o">+</span> <span class="n">printexp</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">getLeftChild</span><span class="p">())</span>
      <span class="n">sVal</span> <span class="o">=</span> <span class="n">sVal</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">getRootVal</span><span class="p">())</span>
      <span class="n">sVal</span> <span class="o">=</span> <span class="n">sVal</span> <span class="o">+</span> <span class="n">printexp</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">getRightChild</span><span class="p">())</span><span class="o">+</span><span class="s">&#39;)&#39;</span>
  <span class="k">return</span> <span class="n">sVal</span>
</pre></div>
</div>
<p>The following Python session shows the <tt class="docutils literal"><span class="pre">printexp</span></tt> and
<tt class="docutils literal"><span class="pre">postordereval</span></tt> methods in action.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pythonds.trees</span> <span class="kn">import</span> <span class="n">BinaryTree</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">(</span><span class="s">&#39;*&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">insertLeft</span><span class="p">(</span><span class="s">&#39;+&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">getLeftChild</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span><span class="o">.</span><span class="n">insertLeft</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span><span class="o">.</span><span class="n">insertRight</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">insertRight</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">printexp</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">(((4) + (5)) * (7))</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">postordereval</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">63</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Notice that the <tt class="docutils literal"><span class="pre">printexp</span></tt> function as we have implemented it puts
parentheses around each number. While not incorrect, the parentheses are
clearly not needed. In the exercises at the end of this chapter you are
asked to modify the <tt class="docutils literal"><span class="pre">printexp</span></tt> function to remove this set of
parentheses.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="heap.html" title="Priority Queues with Binary Heaps"
             >next</a> |</li>
        <li class="right" >
          <a href="implementation.html" title="Implementation"
             >previous</a> |</li>
        <li><a href="../index.html">Python Courseware</a> &raquo;</li>
<li class="right"><span class="loginout"><a href="/runestone/default/user/logout">logout</a></span>| </li>

      </ul>
    </div>

    <div class="footer">
        &copy; Copyright 2012, Brad Miller, David Ranum.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b1.
    </div>

<script type="text/javascript" charset="utf-8">
    $(document).ready(addUserToFooter)
    $(document).ready(createEditors);
    $(document).ready(getNumUsers);
    $(document).ready(getOnlineUsers);
</script>




  </body>
</html>